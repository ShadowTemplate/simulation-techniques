##
# Defines a generic module that is used to run specific tests
# about the data collected before the simulation.
import numpy
from pylab import *
from scipy.stats import stats
from jobshop.misc.Constants import Constants
from jobshop.statistics.Distributions import GaussianDistribution, ExponentialDistribution, UniformDistribution


##
# Performs these tests:
# - Frequency graph for exponentially distributed values generated by the scipy distribution
# - Frequency graph for normally distributed values generated by the scipy distribution
# - QQ plots between Normal distribution, Uniform distribution and Exponential distribution
# - Chi-square test between exponentially distributed values and normally distributed values
# - Chi-square test between exponentially distributed values and other exponentially distributed values
# - Kolgomorov-Smirnov test between exponentially distributed values and normally distributed values
# - Kolgomorov-Smirnov test between exponentially distributed values and other exponentially distributed values
#
# @param values an array with different number of samples that will be used to run the evaluation process
def run(values):
    rcParams['figure.figsize'] = Constants.FIGURE_WIDTH, Constants.FIGURE_HEIGHT
    num_test = 100
    alpha = 0.1
    exp_distr = ExponentialDistribution(Constants.ARRIVAL_RATE)
    norm_distr = GaussianDistribution(Constants.STATION1_DISTRIBUTIONS[1][0], Constants.STATION1_DISTRIBUTIONS[1][1])
    uniform_distr = UniformDistribution(0, 5)

    for num_samples in values:
        print('Samples number: ', num_samples, '\n')
        exp_values = exp_distr.get_sample_data(num_samples)
        norm_values = norm_distr.get_sample_data(num_samples)

        _frequency_histogram('Samples: {0} - Histogram - {1}'.format(num_samples, str(exp_distr)), exp_values)
        _frequency_histogram('Samples: {0} - Histogram - {1}'.format(num_samples, str(norm_distr)), norm_values)

        _qq_plot('Samples: {0} - QQ Plot - {1} vs {2}'.format(num_samples, str(exp_distr), str(uniform_distr)), exp_values, uniform_distr)
        _qq_plot('Samples: {0} - QQ Plot - {1} vs {2}'.format(num_samples, str(exp_distr), str(exp_distr)), exp_values, exp_distr)
        _qq_plot('Samples: {0} - QQ Plot - {1} vs {2}'.format(num_samples, str(norm_distr), str(uniform_distr)), norm_values, uniform_distr)
        _qq_plot('Samples: {0} - QQ Plot - {1} vs {2}'.format(num_samples, str(norm_distr), str(norm_distr)), norm_values, norm_distr)

        print('Chi-square test - alpha:', alpha, '-', str(exp_distr), 'vs', str(uniform_distr))
        num_rej = _run_test(_chi_square_test, num_test, uniform_distr, exp_distr, num_samples, alpha)
        print('Rejected ', num_rej, '/', num_test, '\n')

        print('Chi-square test - alpha:', alpha, '-', str(exp_distr), 'vs', str(exp_distr))
        num_rej = _run_test(_chi_square_test, num_test, exp_distr, exp_distr, num_samples, alpha)
        print('Rejected ', num_rej, '/', num_test, '\n')

        print('Chi-square test - alpha:', alpha, '-', str(norm_distr), 'vs', str(uniform_distr))
        num_rej = _run_test(_chi_square_test, num_test, uniform_distr, norm_distr, num_samples, alpha)
        print('Rejected ', num_rej, '/', num_test, '\n')

        print('Chi-square test - alpha:', alpha, '-', str(norm_distr), 'vs', str(norm_distr))
        num_rej = _run_test(_chi_square_test, num_test, norm_distr, norm_distr, num_samples, alpha)
        print('Rejected ', num_rej, '/', num_test, '\n')

        print('\nKolomogorov-Smirnov test - alpha:', alpha, '-', str(exp_distr), 'vs', str(uniform_distr))
        num_rej = _run_test(_kolmogorov_smirnov_test, num_test, exp_distr, 'uniform', num_samples, alpha, 0, 5)
        print('Rejected ', num_rej, '/', num_test, '\n')

        print('Kolomogorov-Smirnov test - alpha:', alpha, '-', str(exp_distr), 'vs', str(exp_distr))
        num_rej = _run_test(_kolmogorov_smirnov_test, num_test, exp_distr, 'uniform', num_samples, alpha)
        print('Rejected ', num_rej, '/', num_test, '\n')

        print('Kolomogorov-Smirnov test - alpha:', alpha, '-', str(norm_distr), 'vs', str(uniform_distr))
        num_rej = _run_test(_kolmogorov_smirnov_test, num_test, norm_distr, 'uniform', num_samples, alpha, 0, 5)
        print('Rejected ', num_rej, '/', num_test, '\n')

        print('Kolomogorov-Smirnov test - alpha:', alpha, '-', str(norm_distr), 'vs', str(norm_distr))
        num_rej = _run_test(_kolmogorov_smirnov_test, num_test, norm_distr, 'norm', num_samples, alpha, Constants.STATION1_DISTRIBUTIONS[1][0], Constants.STATION1_DISTRIBUTIONS[1][1])
        print('Rejected ', num_rej, '/', num_test)

        print('\n')


##
# Runs a specific test using the data specified in input.
#
# @param test_function the statistical function that will be used to test the data
# @param num_test number of test that will be done using the specified function
# @param distr1 distribution that will be checked
# @param distr2 reference distribution
# @param samples_param if the origin distribution is exponentially distributed this value represents
# the amount of time used to generated exponentially distributed values; if another distribution
# is specified this value represents the number of values to be generated
# @param alpha confidence level for the statistical test
# @param args if the test_function is the chi-square test args represents the intervals number;
# if the test_function is the Kolmogorov-Smirnov test it represents the parameters of the
# reference distribution
def _run_test(test_function, num_test, distr1, distr2, samples_param, alpha, *args):
    num_rej = 0
    if test_function.__name__ == _chi_square_test.__name__:
        for _ in range(num_test):
            if not _chi_square_test(distr1.get_sample_data(samples_param), distr2.get_sample_data(samples_param), alpha, None if not args else args[0]):
                num_rej += 1
    elif test_function.__name__ == _kolmogorov_smirnov_test.__name__:
        for _ in range(num_test):
            if isinstance(distr1, ExponentialDistribution):
                values = _get_uniformed_exp_values(distr1, samples_param * 10)
            else:
                values = distr1.get_sample_data(samples_param)
            if not _kolmogorov_smirnov_test(values, distr2, alpha, None if not args else args):
                num_rej += 1
    return num_rej


##
# Shows the frequency histogram generated from the input values.
# Optionally, it can be specified the number of intervals that will be
# used to group the values. The default values is the state-of-the-art
# square root of the input size.
#
# @param title window's title in which will be showed the frequency histogram
# @param samples the data that will be analyzed
# @param params number of intervals used for the analysis (params[0])
#
def _frequency_histogram(title, samples, *params):
    number_of_intervals = params[0] if params else numpy.sqrt(len(samples))

    histogram, bins = numpy.histogram(samples, bins=number_of_intervals)
    width = 0.7 * (bins[1] - bins[0])
    center = (bins[:-1] + bins[1:]) / 2

    fig = plt.figure()
    plt.bar(center, histogram, align='center', width=width)
    fig.suptitle(title, fontsize=20)
    plt.show()


##
# Starting from a sample data array (whose length is N), generates
# an array of quantiles values using the inverse function of the
# theoretical distribution specified in input.
#
# @param samples sample data for which will be generated the array of quantiles
# @param theoretical_distr distribution that will be used as a reference
# @return the array of quantiles for the sample data specified
#
def _generate_quantile_array(samples, theoretical_distr):
    n = len(samples)
    return [theoretical_distr.get_inverse((j - 0.5) / n) for j in range(n)]


##
# Shows the QQ plot in order to compare the sample data specified
# with the theoretical distribution.
#
# @param title window's title
# @param samples the data collected
# @param theoretical_distr the distribution that will be used as a reference
def _qq_plot(title, samples, theoretical_distr):
    samples = sorted(samples)
    quantile_values = _generate_quantile_array(samples, theoretical_distr)
    fig = plt.figure()
    plt.plot(samples, quantile_values)
    fig.suptitle(title, fontsize=20)
    plt.show()


##
# Runs the Kolgomorov-Smirnov test between the sample data
# and a specific theoretical distribution using a specific value for the
# significance of the test.
#
# This test can be run using as a reference distribution only the uniform
# or the normal distribution.
#
# @param samples sample data on which will be executed the test
# @param dst_distr_name name of the reference distribution ('uniform' or 'norm')
# @param alpha significance level of the test
# @param params parameters for the theoretical distribution used
#
# @return True if the null hypothesis is not rejected, False otherwise
def _kolmogorov_smirnov_test(samples, dst_distr_name, alpha, params=None):
    num_samples = len(samples)

    if dst_distr_name == 'uniform':
        curr_args = (params[0], params[1]) if params else ()
    elif dst_distr_name == 'norm':
        curr_args = (params[0], params[1]) if params else ()
    else:
        raise ValueError('Unsupported destination distribution')

    if curr_args:
        d, p_val = stats.kstest(samples, dst_distr_name, args=curr_args, mode="asymp")
    else:
        d, p_val = stats.kstest(samples, dst_distr_name, mode="asymp")

    # Computes the critical value considering the number of examples
    if num_samples > 35:
        critical_d = Constants.KS_CRITICAL_VALUES['over'][alpha] / sqrt(num_samples)
    else:
        critical_d = Constants.KS_CRITICAL_VALUES[num_samples][alpha]

    return d <= critical_d


##
# Runs the chi-square test between the sample data specified and some
# other generated using a specific distribution using a specific value for the
# significance of the test.
#
# @param ref_samples reference values for the test
# @param obs_samples observed data for the test
# @param alpha significance level for the test
# @param num_int number of interval in which the values will be grouped
#
# @return True if the null hypothesis is not reject, False otherwise
def _chi_square_test(ref_samples, obs_samples, alpha, num_int=None):
    samples_num = len(ref_samples)
    test_value_present = False if Constants.CS_TEST_VALUES.get(samples_num - 1) is None else True

    # checks if the number of samples is the same and if
    # is present a critical value for the specified significance level
    assert samples_num == len(obs_samples) and test_value_present

    num_interval = num_int if num_int else math.ceil(sqrt(samples_num))

    # distributes appropriately the reference values in the chosen number of intervals
    ref_samples = sorted(ref_samples)

    freq_values_ref = [math.floor(samples_num / num_interval) for _ in range(num_interval)]
    if samples_num % num_interval != 0:
        freq_values_ref[-1] += samples_num - num_interval * freq_values_ref[0]

    ranges_ref = [ref_samples[(i + 1) * freq_values_ref[0] - 1] if i != num_interval else ref_samples[-1] for i in range(num_interval)]

    freq_values_obs = [0 for _ in range(num_interval)]
    obs_samples = sorted(obs_samples)

    curr_index = 0

    for data in obs_samples:
        while data > ranges_ref[curr_index] and curr_index != num_interval - 1:
            curr_index += 1
        freq_values_obs[curr_index] += 1

    tot_sum = sum([pow(freq_values_obs[i] - freq_values_ref[i], 2) / freq_values_ref[i] for i in range(num_interval)])

    return tot_sum < Constants.CS_TEST_VALUES[samples_num - 1][alpha]


##
# Generates uniform data from an exponential distribution.
# If the arrival time {T1, T2, T3, ...} distribution is exponential then
# the arrival times are uniformly distributed on the interval (0,T).
# So the interarrival times are normalized using cumulative sums.
#
# @param distr specific exponential distribution
# @param max_time time interval in which will be generated the values
def _get_uniformed_exp_values(distr, max_time):
    values = []
    t = 0
    while t < max_time:
        values.append(distr.next())
        t += values[-1]

    uniformed_values = []
    curr_tot = 0

    for i in range(len(values) - 1):
        curr_tot += values[i]
        uniformed_values.append(curr_tot / max_time)

    return uniformed_values
